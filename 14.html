<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>Bungee Alice</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body{font-family:'Inter',sans-serif;background-color:#f0f4f8;display:flex;justify-content:center;align-items:center;min-height:100vh;margin:0;overflow:hidden}
        .app-container{display:flex;flex-direction:column;align-items:center;width:100%;height:100vh;position:relative}
        .card-section{background-color:#fff;border-radius:1rem;box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05);overflow:hidden;width:80%;max-width:600px;padding:1.5rem;box-sizing:border-box}
        #taskPlannerSection{min-height:500px;display:flex;flex-direction:column;justify-content:center;align-items:center}
        .bungee-jumper{transition:transform 1s ease-in-out,opacity 1s ease-in-out;transform-origin:center top}
        .bungee-jumper.diving{transform:translateY(150vh) rotate(360deg);opacity:0}
        .task-block{min-width:20px;flex-grow:1;flex-shrink:1;transition:background-color .3s ease;box-sizing:border-box}
        .task-block.dragging{opacity:.5;border:2px dashed #93c5fd}
        .task-block.drag-over-left{border-left:3px solid #6366f1}
        .task-block.drag-over-right{border-right:3px solid #6366f1}
        .resize-handle{background-color:rgba(0,0,0,.2);transition:background-color .2s ease}
        .resize-handle:hover{background-color:rgba(0,0,0,.4)}
        .resizing-cursor{cursor:ew-resize!important}
        #trashCan{transition:all .3s ease}
        #trashCan.drag-over-trash{background-color:#ef4444;color:#fff;transform:scale(1.1)}
        #gradientSection{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:80%;max-width:600px;height:80vh;max-height:700px;padding:0;display:none;flex-direction:row;justify-content:center;align-items:stretch;overflow:hidden}
        .left-gradient{flex-grow:1;display:flex;flex-direction:column;position:relative;overflow:hidden}
        .background-scroller{position:absolute;top:0;left:0;width:100%;display:flex;flex-direction:column}
        .bungee-jumper-image{position:absolute;left:50%;top:0;transform:translateX(-50%);width:auto;height:40%;opacity:.8;z-index:10}
        .right-gradient{width:80px;display:flex;flex-direction:column;border-left:1px solid rgba(0,0,0,.1);position:relative;overflow:hidden}
        .bungee-jumper-image-small{position:absolute;left:50%;transform:translateX(-50%);width:auto;height:8%;opacity:.8;z-index:10}
        .color-block-left{flex-shrink:0;width:100%;border-bottom:1px solid rgba(0,0,0,.1)}
        .color-block-left:last-child{border-bottom:none}
        .color-block-right{flex-grow:1;min-height:5px;border-bottom:1px solid rgba(0,0,0,.05)}
        .color-block-right:last-child{border-bottom:none}
        /* Style for the new black task markers on the right gradient */
        .task-marker-right {
            position: absolute;
            left: 0;
            width: 100%;
            height: 1px; /* Very thin line */
            background-color: black;
            z-index: 12; /* Ensure it's above other elements */
            pointer-events: none; /* Make it non-interactive */
        }
        .task-marker-right span {
            position: absolute;
            right: 2px; /* Position label to the right */
            top: -6px; /* Adjust vertical position */
            color: black;
            font-size: 0.5rem; /* Smaller font for conciseness */
            text-shadow: 0.5px 0.5px 1px white; /* Subtle shadow for readability */
            white-space: nowrap;
            opacity: 0.7; /* Slightly transparent */
        }
        /* Style for left task markers */
        .task-marker-left {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: white;
            z-index: 11;
            pointer-events: none;
        }
        .task-marker-left span {
            position: absolute;
            left: 5px;
            top: -10px;
            color: white;
            font-size: 0.75rem;
            text-shadow: 1px 1px 2px black;
            white-space: nowrap;
        }
        /* Session Review Modal styles */
        #sessionReviewModal {
            position: fixed; /* Ensures it's always on top */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75); /* Dark overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100; /* Ensure it's above everything else */
            padding: 1rem;
            /* IMPORTANT: Default to hidden using CSS */
            display: none; 
        }
        #sessionReviewModal .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            max-height: 90vh; /* Limit height for scrollability */
            overflow-y: auto; /* Enable scrolling for many tasks */
        }
        .review-task-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 0;
            border-bottom: 1px solid #e2e8f0;
        }
        .review-task-item:last-child {
            border-bottom: none;
        }
        .review-task-name {
            flex-grow: 1;
            font-weight: 600;
            color: #333;
        }
        .review-task-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Task Completion Modal styles */
        #taskCompletionModal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99; /* Below sessionReviewModal */
            padding: 1rem;
            display: none; /* Hidden by default */
        }
        #taskCompletionModal .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            text-align: center;
        }
        /* New: Skip Task Button styling for gradient section */
        #skipTaskButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: #007bff; /* Blue for action */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px; /* Pill shape */
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, transform 0.2s ease;
            cursor: pointer;
            z-index: 90; /* Ensure it's above background elements */
        }
        #skipTaskButton:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #skipTaskButton:active {
            transform: translateY(0);
        }
        #skipTaskButton:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div id="taskPlannerSection" class="card-section">
            <button id="helpButton" class="absolute top-4 left-4 bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out">help</button>
            <div id="helpModal" class="hidden fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50 p-4">
                <div class="bg-white rounded-lg p-6 max-w-sm w-full shadow-xl">
                    <h3 class="text-xl font-bold mb-4 text-gray-900">How to Use Bungee Alice</h3>
                    <p class="text-gray-700 mb-4">This site helps you work in 25-minute increments, inspired by the Pomodoro Technique.</p>
                    <ul class="list-disc list-inside text-gray-700 mb-4">
                        <li>Type your task in the text box.</li><li>Click the '+' button to add it to the timeline.</li>
                        <li>Tasks will split the 25 minutes evenly by default.</li>
                        <li><b>Drag the vertical lines between task blocks</b> to adjust their duration.</li>
                        <li><b>Drag and drop the task blocks themselves</b> to reorder them.</li>
                        <li><b>Drag a task block onto the trash can</b> to delete it.</li>
                        <li>Click 'DIVE IN' to start your focused work session!</li>
                    </ul>
                    <button id="closeHelpModal" class="mt-4 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg w-full shadow-md transition duration-300 ease-in-out">Got It!</button>
                </div>
            </div>

            <!-- Session Review Modal - Initially hidden using CSS -->
            <div id="sessionReviewModal">
                <div class="modal-content">
                    <h3 class="text-2xl font-bold mb-4 text-gray-900 text-center">Session Review</h3>
                    <div id="reviewTaskList" class="space-y-4 max-h-80 overflow-y-auto mb-6 p-2 rounded-lg bg-gray-50 border border-gray-200">
                        <!-- Tasks will be rendered here dynamically -->
                    </div>
                    <button id="finishReviewButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg w-full shadow-md transition duration-300 ease-in-out">
                        Finish Review
                    </button>
                </div>
            </div>


            <div class="w-48 sm:w-64 md:w-80 h-auto mb-6 flex justify-center items-center overflow-hidden">
                <img id="bungeeJumper" src="https://raw.githubusercontent.com/boobalootoo/bungeealice/refs/heads/main/jump-removebg-preview.png" alt="Bungee jumping character silhouette" class="bungee-jumper w-full h-full object-contain" onerror="this.onerror=null;this.src='https://placehold.co/300x400/CCCCCC/333333?text=Image+Not+Found';">
            </div>
            <div class="flex items-center w-full mb-6">
                <input type="text" id="mainTaskInput" placeholder="Type what you want to do in the next 25 minutes" class="flex-grow p-3 border border-gray-300 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 shadow-sm text-gray-800"/>
                <button id="addTaskButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-3 rounded-r-lg shadow-md transition duration-300 ease-in-out">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4"/></svg>
                </button>
            </div>
            <div class="flex items-center w-full mb-2">
                <div id="tasksContainer" class="flex flex-row items-stretch h-24 flex-grow bg-gray-200 rounded-l-lg overflow-hidden relative border border-gray-300"></div>
                <div id="trashCan" class="flex-shrink-0 w-16 h-24 flex items-center justify-center bg-gray-300 rounded-r-lg ml-1 border border-gray-300 cursor-pointer text-gray-600 hover:bg-gray-400">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
                </div>
            </div>
            <div class="time-markers flex justify-between w-full max-w-md px-2 text-lg text-gray-600 font-semibold mb-8">
                <span>00</span><span>05</span><span>10</span><span>15</span><span>20</span><span>25</span>
            </div>
            <button id="diveInButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-6 rounded-lg text-xl uppercase tracking-wider shadow-lg transform hover:scale-105 transition duration-300 ease-in-out">DIVE IN</button>
        </div>
        <div id="gradientSection" class="card-section">
            <div class="left-gradient" id="leftGradient">
                <div class="background-scroller" id="backgroundScroller"></div>
                <img id="largeJumper" src="https://raw.githubusercontent.com/boobalootoo/bungeealice/refs/heads/main/jump-removebg-preview.png" alt="Bungee Jumper Silhouette Large" class="bungee-jumper-image" onerror="this.onerror=null;this.src='https://placehold.co/300x400/CCCCCC/333333?text=Image+Not+Found';">
            </div>
            <div class="right-gradient" id="rightGradient">
                <img id="smallJumper" src="https://raw.githubusercontent.com/boobalootoo/bungeealice/refs/heads/main/jump-removebg-preview.png" alt="Bungee Jumper Silhouette Small" class="bungee-jumper-image-small" onerror="this.onerror=null;this.src='https://placehold.co/300x400/CCCCCC/333333?text=Image+Not+Found';">
            </div>
            <!-- New: Skip Task Button -->
            <button id="skipTaskButton" class="rounded-full">Next Task</button>
        </div>

        <!-- In-App Task Completion Modal -->
        <div id="taskCompletionModal" class="hidden">
            <div class="modal-content">
                <h3 class="text-2xl font-bold mb-4 text-gray-900">Task Completed?</h3>
                <p class="text-gray-700 text-lg mb-2">Did you complete "<span id="completedTaskName" class="font-semibold text-indigo-700"></span>" (<span id="completedTaskDuration" class="font-semibold text-indigo-700"></span> min)?</p>
                <div id="timeNeededSection" class="hidden flex flex-col items-center mt-4 mb-6">
                    <label for="extraTimeInput" class="text-gray-700 text-sm mb-2">How many more minutes do you need?</label>
                    <input type="number" id="extraTimeInput" min="0" value="5" class="w-24 p-2 border border-gray-300 rounded-md text-center text-lg focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="flex flex-col space-y-3">
                    <button id="taskYesButton" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out">
                        Yes, Completed!
                    </button>
                    <button id="taskNoButton" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out">
                        No, Need More Time
                    </button>
                    <button id="taskSkipButtonModal" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out">
                        Skip Task
                    </button>
                </div>
            </div>
        </div>
        <!-- End In-App Task Completion Modal -->

    </div>
    <script>
        // Global tasks array to be shared and modified by modules
        let tasks = []; 
        // Global references for modals
        let sessionReviewModalElement; 
        let taskCompletionModalElement; 

        function hexToRgb(hex){const bigint=parseInt(hex.slice(1),16);return{r:(bigint>>16)&255,g:(bigint>>8)&255,b:bigint&255}}
        function rgbToHex(r,g,b){return"#"+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1).padStart(6,'0').toUpperCase()}
        function generateGradient(startHex,endHex,steps){
            const startRgb=hexToRgb(startHex),endRgb=hexToRgb(endHex),colors=[];
            for(let i=0;i<steps;i++){
                const factor=steps===1?0:i/(steps-1);
                const r=Math.round(startRgb.r+factor*(endRgb.r-startRgb.r));
                const g=Math.round(startRgb.g+factor*(endRgb.g-startRgb.g));
                const b=Math.round(startRgb.b+factor*(endRgb.b-startRgb.b));
                colors.push(rgbToHex(r,g,b));
            }
            return colors;
        }

        const taskPlanner=(function(){
            const D=document,
            helpButton=D.getElementById('helpButton'),helpModal=D.getElementById('helpModal'),closeHelpModal=D.getElementById('closeHelpModal'),addTaskButton=D.getElementById('addTaskButton'),
            tasksContainer=D.getElementById('tasksContainer'),mainTaskInput=D.getElementById('mainTaskInput'),diveInButton=D.getElementById('diveInButton'),bungeeJumper=D.getElementById('bungeeJumper'),
            trashCan=D.getElementById('trashCan'),taskPlannerSection=D.getElementById('taskPlannerSection');

            let colorIndex=0,draggedItem=null;
            const COLORS=['#ef4444','#f97316','#facc15','#22c55e','#06b6d4','#3b82f6','#6366f1'];
            let isResizing=false,currentBlock=null,nextBlock=null,currentTaskData=null,nextTaskData=null,startX=0,startWidthCurrent=0,startWidthNext=0;
            let timelineNeedsRender = false;

            const getNextColor=()=>COLORS[colorIndex++%COLORS.length];
            const clearDragOverClasses=()=>{D.querySelectorAll('.task-block').forEach(b=>b.classList.remove('drag-over-left','drag-over-right'));trashCan.classList.remove('drag-over-trash')};
            
            function renderTimeline(){
                tasksContainer.innerHTML='';D.body.classList.remove('resizing-cursor');
                tasks.forEach((task,idx)=>{
                    const taskBlock=D.createElement('div');
                    taskBlock.id=task.id;
                    taskBlock.className='task-block flex flex-col justify-center items-center text-white text-sm font-semibold relative group overflow-hidden whitespace-nowrap truncate px-2';
                    taskBlock.style.backgroundColor=task.color;
                    taskBlock.style.flexBasis=`${(task.duration/25)*100}%`;taskBlock.style.minWidth='20px';taskBlock.draggable=true;

                    const taskNameDiv=D.createElement('div');taskNameDiv.className='p-1 text-center';taskNameDiv.textContent=task.name;taskBlock.appendChild(taskNameDiv);
                    const taskDurDiv=D.createElement('div');taskDurDiv.className='text-xs font-normal text-gray-100';taskDurDiv.textContent=`${task.duration.toFixed(1)} min`;taskBlock.appendChild(taskDurDiv);

                    if(idx < tasks.length - 1){
                        const resizeHandle=D.createElement('div');resizeHandle.className='resize-handle absolute top-0 right-0 bottom-0 w-2 cursor-ew-resize z-10';taskBlock.appendChild(resizeHandle);
                        resizeHandle.addEventListener('mousedown',e=>{
                            isResizing=true;currentBlock=taskBlock;nextBlock=taskBlock.nextSibling;currentTaskData=tasks[idx];nextTaskData=tasks[idx+1];
                            startX=e.clientX;startWidthCurrent=currentBlock.offsetWidth;startWidthNext=nextBlock.offsetWidth;
                            D.addEventListener('mousemove',onMouseMove);D.addEventListener('mouseup',onMouseUp);D.body.classList.add('resizing-cursor');e.preventDefault();
                        });
                    }
                    tasksContainer.appendChild(taskBlock);
                });
                D.querySelectorAll('.task-block').forEach(addDragAndDropListeners);
            }

            const distributeTimeEvenly=()=>{if(tasks.length===0){renderTimeline();return}const dur=25/tasks.length;tasks.forEach(t=>t.duration=dur);renderTimeline()};

            function addDragAndDropListeners(block){
                block.addEventListener('dragstart',e=>{
                    draggedItem=block;
                    setTimeout(()=>block.classList.add('dragging'),0);
                    e.dataTransfer.setData('text/plain',block.id);
                    e.dataTransfer.effectAllowed='move'
                });
                block.addEventListener('dragend',()=>{
                    block.classList.remove('dragging');
                    draggedItem=null;
                    if (timelineNeedsRender) {
                        renderTimeline();
                        timelineNeedsRender = false;
                    }
                });
                block.addEventListener('dragover',e=>{
                    e.preventDefault();const dropTarget=e.target.closest('.task-block'),isOverTrash=e.target.closest('#trashCan');clearDragOverClasses();
                    if(isOverTrash){trashCan.classList.add('drag-over-trash')}
                    else if(draggedItem&&dropTarget&&draggedItem!==dropTarget){
                        const rect=dropTarget.getBoundingClientRect(),offset=e.clientX-rect.left;dropTarget.classList.add(offset<rect.width/2?'drag-over-left':'drag-over-right');
                    }
                });
                block.addEventListener('dragleave',e=>{const tar=e.target.closest('.task-block');if(tar)tar.classList.remove('drag-over-left','drag-over-right');if(!e.relatedTarget||!e.relatedTarget.closest('#trashCan'))trashCan.classList.remove('drag-over-trash')});
                block.addEventListener('drop',e=>{
                    e.preventDefault();trashCan.classList.remove('drag-over-trash');
                    const iTD=e.dataTransfer.getData('text/plain');const idx=tasks.findIndex(t=>t.id===iTD);
                    const isDroppedOnTrash = e.target.closest('#trashCan');

                    if (draggedItem && isDroppedOnTrash) {
                        if (idx > -1) {
                            tasks.splice(idx, 1);
                            distributeTimeEvenly();
                            timelineNeedsRender = false;
                        }
                    } else if (draggedItem && dropTarget && draggedItem !== dropTarget) {
                        const dragIdx = tasks.findIndex(t => t.id === draggedItem.id);
                        const dropIdx = tasks.findIndex(t => t.id === dropTarget.id);
                        
                        const [removed] = tasks.splice(dragIdx, 1);
                        tasks.splice(e.clientX - dropTarget.getBoundingClientRect().left < dropTarget.offsetWidth / 2 ? dropIdx : dropIdx + 1, 0, removed);
                        timelineNeedsRender = true;
                    }
                });
            }

            function onMouseMove(e){
                if(!isResizing)return;const deltaX=e.clientX-startX,cW=tasksContainer.offsetWidth,minPx=20;
                let newCW=startWidthCurrent+deltaX,newNW=startWidthNext-deltaX;
                newCW=Math.max(minPx,newCW);newNW=Math.max(minPx,newNW);
                const curTotW=startWidthCurrent+startWidthNext;
                if(newCW+newNW!==curTotW){if(newCW===minPx)newNW=curTotW-minPx;else if(newNW===minPx)newCW=curTotW-minPx;}
                currentBlock.style.flexBasis=`${(newCW/cW)*100}%`;nextBlock.style.flexBasis=`${(newNW/cW)*100}%`;
                currentTaskData.duration=(newCW/cW)*25;nextTaskData.duration=(newNW/cW)*25;
                currentBlock.querySelector('.text-xs').textContent=`${currentTaskData.duration.toFixed(1)} min`;
                nextBlock.querySelector('.text-xs').textContent=`${nextTaskData.duration.toFixed(1)} min`;
            }

            function onMouseUp(){
                isResizing=false;currentBlock=nextBlock=currentTaskData=nextTaskData=null;
                D.removeEventListener('mousemove',onMouseMove);D.removeEventListener('mouseup',onMouseUp);D.body.classList.remove('resizing-cursor');
                renderTimeline();
            }

            function init(sessionStartCallback){
                helpButton.onclick=()=>helpModal.classList.remove('hidden');closeHelpModal.onclick=()=>helpModal.classList.add('hidden');
                addTaskButton.onclick=()=>{
                    let name=mainTaskInput.value.trim()||`Task ${tasks.length+1}`;
                    tasks.push({id:`task-${Date.now()}`,name:name,duration:0,color:getNextColor(), completed: false, timeNeeded: 0}); 
                    distributeTimeEvenly();mainTaskInput.value='';
                };
                diveInButton.onclick=()=>{
                    if(tasks.length === 0) {
                        alert("Please add at least one task before diving in!");
                        return;
                    }
                    if ('Notification' in window) {
                        Notification.requestPermission().then(permission => {
                            if (permission === 'granted') {
                                console.log('Notification permission granted.');
                            } else if (permission === 'denied') {
                                console.warn('Notification permission denied. System notifications will not be shown.');
                            }
                        }).catch(error => {
                            console.error('Error requesting notification permission:', error);
                        });
                    } else {
                        console.warn('This browser does not support desktop notifications.');
                    }

                    bungeeJumper.classList.add('diving');
                    bungeeJumper.addEventListener('transitionend',()=>{{
                        taskPlannerSection.style.display='none';
                        sessionStartCallback(JSON.parse(JSON.stringify(tasks)));
                    }},{once:true});
                };
                trashCan.addEventListener('dragover',e=>{e.preventDefault();trashCan.classList.add('drag-over-trash')});
                trashCan.addEventListener('dragleave',()=>trashCan.classList.remove('drag-over-trash'));
                trashCan.addEventListener('drop',e=>{
                    e.preventDefault();trashCan.classList.remove('drag-over-trash');
                    const iTD=e.dataTransfer.getData('text/plain');const idx=tasks.findIndex(t=>t.id===iTD);
                    if(idx>-1){tasks.splice(idx,1);distributeTimeEvenly()}
                });
                renderTimeline();
            }
            return {init, renderTimeline};
        })();

        const handleSessionCompletion = (sessionTasks) => {
            console.log("handleSessionCompletion called. Session completed! Tasks:", sessionTasks);
            // Clear the timeout to prevent it from firing if we're manually ending the session
            if (gradientAnimation.sessionTimeout) {
                clearTimeout(gradientAnimation.sessionTimeout);
                console.log("Cleared sessionTimeout.");
            }
            cancelAnimationFrame(gradientAnimation.animationFrameId);
            document.getElementById('gradientSection').style.display = 'none';
            document.getElementById('taskPlannerSection').style.display = 'flex';

            console.log("Checking Notification API support and permission for final notification...");
            if ('Notification' in window && Notification.permission === 'granted') {
                console.log("Notification API supported and permission granted. Attempting to create final session notification.");
                try {
                    const notification = new Notification('Session Completed!', {
                        body: 'Your 25-minute focus session is over. Click to review your tasks!',
                        icon: 'https://placehold.co/64x64/3b82f6/ffffff?text=ðŸ'
                    });
                    notification.addEventListener('click', function() {
                        console.log("Notification clicked. Focusing window and showing review modal.");
                        window.focus();
                        gradientAnimation.showSessionReviewModal(sessionTasks);
                    });
                    notification.addEventListener('close', function() {
                        console.log('Session end notification closed without action. Showing review modal.');
                        gradientAnimation.showSessionReviewModal(sessionTasks);
                    });
                    console.log("Notification created successfully.");
                } catch (error) {
                    console.error("Error creating end-of-session notification:", error);
                    gradientAnimation.showSessionReviewModal(sessionTasks);
                }
            } else {
                console.warn("Notifications not available or permission denied. Showing review modal directly.");
                gradientAnimation.showSessionReviewModal(sessionTasks);
            }
        };

        const gradientAnimation=(function(){
            const D=document; 
            let gradientSection, leftGradientContainer, backgroundScroller, rightGradientContainer, largeJumper, smallJumper;
            let reviewTaskList, finishReviewButton;
            let completedTaskNameSpan, completedTaskDurationSpan, taskYesButton, taskNoButton, taskSkipButtonModal, extraTimeInput, timeNeededSection;
            let skipTaskButton; 

            const segments=[
                {start:'#5C0000',end:'#E50000'},{start:'#E65C00',end:'#FF9900'},
                {start:'#E6A300',end:'#FFFF00'},{start:'#008000',end:'#00FF00'},
                {start:'#005050',end:'#00C0C0'}
            ];

            let allColors=[],leftColors,rightColors,_sessionTasks=[];
            let lastTimestamp=0,animationFrameId;
            let sessionTimeout = null; // Declare sessionTimeout here
            let leftContH=0,rightContH=0,largeJumperH=0,smallJumperH=0,largeSectH=0,smallSectH=0;
            let imagesLoadedCount=0;const totalImages=2;

            let smashSound;
            const totalSessionDuration = 25 * 60 * 1000;
            let elapsedSessionTime = 0;
            let currentTaskIndex = 0;
            let currentTaskStartTime = 0;
            let currentTaskLogicalStartTimeMs = 0;
            let currentTaskLogicalEndTimeMs = 0;

            function populateRightGradient(){
                rightGradientContainer = D.getElementById('rightGradient'); 
                rightGradientContainer.querySelectorAll('.color-block-right').forEach(b=>b.remove());
                rightGradientContainer.querySelectorAll('.task-marker-right').forEach(m => m.remove());

                smallSectH=rightGradientContainer.offsetHeight/25;
                rightColors.forEach(c=>{const d=D.createElement('div');d.className='color-block-right';d.style.height=`${smallSectH}px`;d.style.backgroundColor=c;rightGradientContainer.appendChild(d)});
                
                let cumulativeDuration = 0;
                _sessionTasks.forEach((task, index) => { 
                    if (task.duration > 0) {
                        cumulativeDuration += task.duration;
                        const markerTopPx = cumulativeDuration * smallSectH;

                        const markerDiv = D.createElement('div');
                        markerDiv.className = 'task-marker-right';
                        markerDiv.style.top = `${markerTopPx}px`;
                        markerDiv.dataset.markerIndex = index;
                        
                        const labelSpan = D.createElement('span');
                        labelSpan.textContent = `${task.name} (${task.duration.toFixed(1)} min)`;
                        markerDiv.appendChild(labelSpan);
                        rightGradientContainer.appendChild(markerDiv);
                    }
                });
            }

            function showSessionReviewModal(tasksToReview) {
                reviewTaskList.innerHTML = '';
                tasksToReview.forEach((task, index) => {
                    const taskItem = D.createElement('div');
                    taskItem.className = 'review-task-item';
                    taskItem.innerHTML = `
                        <input type="checkbox" id="completed-${task.id}" data-task-id="${task.id}" class="form-checkbox h-5 w-5 text-green-600 rounded">
                        <label for="completed-${task.id}" class="review-task-name text-gray-800">${task.name} (${task.duration.toFixed(1)} min)</label>
                        <div class="review-task-controls">
                            <label for="time-needed-${task.id}" class="text-gray-600 text-sm">Need:</label>
                            <input type="number" id="time-needed-${task.id}" data-task-id="${task.id}" min="0" value="${task.timeNeeded || 0}"
                                class="w-16 p-1 border border-gray-300 rounded-md text-center text-sm focus:ring-indigo-500 focus:border-indigo-500">
                            <span class="text-gray-600 text-sm">min</span>
                        </div>
                    `;
                    reviewTaskList.appendChild(taskItem);

                    const completedCheckbox = taskItem.querySelector(`#completed-${task.id}`);
                    const timeNeededInput = taskItem.querySelector(`#time-needed-${task.id}`);
                    
                    completedCheckbox.checked = task.completed;
                    if (task.completed) {
                        timeNeededInput.disabled = true;
                        timeNeededInput.classList.add('opacity-50', 'bg-gray-100');
                    }

                    completedCheckbox.addEventListener('change', (e) => {
                        const isCompleted = e.target.checked;
                        timeNeededInput.disabled = isCompleted;
                        if (isCompleted) {
                            timeNeededInput.value = 0;
                            timeNeededInput.classList.add('opacity-50', 'bg-gray-100');
                        } else {
                            timeNeededInput.classList.remove('opacity-50', 'bg-gray-100');
                        }
                    });
                });

                sessionReviewModalElement.style.display = 'flex';
                sessionReviewModalElement.querySelector('.modal-content').focus();
            }

            function hideSessionReviewModal() {
                sessionReviewModalElement.style.display = 'none';
                console.log("Session review modal hidden.");
            }

            function showTaskCompletionModal(task) {
                completedTaskNameSpan.textContent = task.name;
                completedTaskDurationSpan.textContent = task.duration.toFixed(1);
                extraTimeInput.value = 5;
                timeNeededSection.classList.add('hidden'); // Hide "Need More Time" section by default

                taskCompletionModalElement.style.display = 'flex';
                taskCompletionModalElement.querySelector('.modal-content').focus();

                taskYesButton.onclick = () => {
                    task.completed = true;
                    task.timeNeeded = 0;
                    smashSound.currentTime = 0;
                    smashSound.play().catch(e => console.error("Error playing sound:", e));
                    hideTaskCompletionModal();
                    startNextTaskAnimation();
                };

                taskNoButton.onclick = () => {
                    timeNeededSection.classList.remove('hidden');
                    taskNoButton.textContent = "Confirm Time Needed";
                    taskNoButton.onclick = () => { // Reassign onclick for confirmation
                        task.completed = false;
                        task.timeNeeded = parseFloat(extraTimeInput.value) || 0;
                        hideTaskCompletionModal();
                        startNextTaskAnimation();
                    };
                };

                taskSkipButtonModal.onclick = () => { 
                    task.completed = false;
                    task.timeNeeded = 0;
                    hideTaskCompletionModal();
                    startNextTaskAnimation();
                };
                console.log(`Showing task completion modal for: ${task.name}`);
                console.log(`Modal display style: ${taskCompletionModalElement.style.display}`);
            }

            function hideTaskCompletionModal() {
                taskCompletionModalElement.style.display = 'none';
                taskNoButton.textContent = "No, Need More Time"; 
                console.log("Task completion modal hidden.");
            }

            function startNextTaskAnimation() {
                currentTaskIndex++;
                if (currentTaskIndex < _sessionTasks.length) {
                    currentTaskLogicalStartTimeMs = 0;
                    for (let i = 0; i < currentTaskIndex; i++) {
                        currentTaskLogicalStartTimeMs += _sessionTasks[i].duration * 60 * 1000;
                    }
                    currentTaskLogicalEndTimeMs = currentTaskLogicalStartTimeMs + (_sessionTasks[currentTaskIndex].duration * 60 * 1000);

                    elapsedSessionTime = currentTaskLogicalStartTimeMs; 
                    lastTimestamp = performance.now(); 

                    updateSkipButtonState();
                    animationFrameId = requestAnimationFrame(animate);
                } else {
                    console.log("All individual tasks in sequence have finished. Animation will continue until 25-minute session ends.");
                    updateSkipButtonState();
                }
            }

            function updateSkipButtonState() {
                if (currentTaskIndex < _sessionTasks.length - 1) {
                    skipTaskButton.textContent = "Next Task";
                    skipTaskButton.disabled = false;
                } else if (currentTaskIndex === _sessionTasks.length - 1) {
                    skipTaskButton.textContent = "End Session";
                    skipTaskButton.disabled = false;
                } else {
                    skipTaskButton.textContent = "Session Running...";
                    skipTaskButton.disabled = true;
                }

                if (totalSessionDuration - elapsedSessionTime < 30 * 1000 && elapsedSessionTime < totalSessionDuration) {
                    skipTaskButton.disabled = true;
                    skipTaskButton.textContent = "Ending Soon...";
                } else if (elapsedSessionTime >= totalSessionDuration) {
                    skipTaskButton.textContent = "Session Over";
                    skipTaskButton.disabled = true;
                }
            }


            function initializeAnimation(){
                gradientSection = D.getElementById('gradientSection');
                leftGradientContainer = D.getElementById('leftGradient');
                backgroundScroller = D.getElementById('backgroundScroller');
                rightGradientContainer = D.getElementById('rightGradient');
                largeJumper = D.getElementById('largeJumper');
                smallJumper = D.getElementById('smallJumper');

                reviewTaskList = D.getElementById('reviewTaskList');
                finishReviewButton = D.getElementById('finishReviewButton');
                
                completedTaskNameSpan = D.getElementById('completedTaskName');
                completedTaskDurationSpan = D.getElementById('completedTaskDuration');
                taskYesButton = D.getElementById('taskYesButton');
                taskNoButton = D.getElementById('taskNoButton');
                taskSkipButtonModal = D.getElementById('taskSkipButtonModal');
                extraTimeInput = D.getElementById('extraTimeInput');
                timeNeededSection = D.getElementById('timeNeededSection');

                skipTaskButton = D.getElementById('skipTaskButton');
                skipTaskButton.onclick = () => {
                    if (currentTaskIndex < _sessionTasks.length) {
                        const currentTask = _sessionTasks[currentTaskIndex];
                        currentTask.completed = false;
                        currentTask.timeNeeded = 0;

                        if (taskCompletionModalElement.style.display === 'flex') {
                            hideTaskCompletionModal();
                        }
                        
                        let cumulativeDurationUpToCurrent = 0;
                        for (let i = 0; i <= currentTaskIndex; i++) {
                            cumulativeDurationUpToCurrent += _sessionTasks[i].duration;
                        }
                        elapsedSessionTime = cumulativeDurationUpToCurrent * 60 * 1000;
                        lastTimestamp = performance.now();

                        startNextTaskAnimation();
                    } else {
                        if (elapsedSessionTime < totalSessionDuration) {
                            elapsedSessionTime = totalSessionDuration;
                            handleSessionCompletion(_sessionTasks);
                        } else {
                            console.log("Skip button clicked, but session already over.");
                        }
                    }
                };


                finishReviewButton.onclick = () => {
                    console.log("Finish Review button clicked.");
                    const updatedTasks = [];
                    reviewTaskList.querySelectorAll('.review-task-item').forEach(item => {
                        const taskId = item.querySelector('input[type="checkbox"]').dataset.taskId;
                        const isCompleted = item.querySelector('input[type="checkbox"]').checked;
                        const timeNeeded = parseFloat(item.querySelector('input[type="number"]').value) || 0;
                        const originalTask = tasks.find(t => t.id === taskId);

                        updatedTasks.push({
                            ...originalTask,
                            completed: isCompleted,
                            timeNeeded: timeNeeded
                        });
                    });
                    tasks = updatedTasks; 
                    console.log("Tasks after review:", tasks);
                    hideSessionReviewModal();
                    taskPlanner.renderTimeline();
                };


                lCH=leftGradientContainer.offsetHeight;rCH=rightGradientContainer.offsetHeight;
                backgroundScroller.innerHTML='';lSH=lCH/5;
                leftColors.forEach(c=>{const d=D.createElement('div');d.className='color-block-left';d.style.height=`${lSH}px`;d.style.backgroundColor=c;backgroundScroller.appendChild(d)});
                backgroundScroller.style.height=`${lSH * 25}px`;

                populateRightGradient(); 
                
                largeJumper.style.top='0px';smallJumper.style.top='0px';
                largeJumperH=largeJumper.offsetHeight;smallJumperH=smallJumper.offsetHeight;
                
                const totalScrollHeight = backgroundScroller.offsetHeight; 
                scrollSpeed_large = totalScrollHeight / totalSessionDuration;
                speed_small = (rCH + smallJumperH) / totalSessionDuration;

                currentTaskIndex = 0;
                elapsedSessionTime = 0;
                currentTaskStartTime = performance.now();
                currentTaskLogicalStartTimeMs = 0;
                currentTaskLogicalEndTimeMs = (_sessionTasks[0]?.duration || 0) * 60 * 1000; 

                lastTimestamp=performance.now();
                updateSkipButtonState();
                animationFrameId=requestAnimationFrame(animate);

                // Set a timeout for the full 25-minute session
                if (sessionTimeout) clearTimeout(sessionTimeout); // Clear any old timeouts if re-initializing
                sessionTimeout = setTimeout(() => {
                    console.log("Session Timeout triggered after 25 minutes. Calling handleSessionCompletion.");
                    handleSessionCompletion(_sessionTasks);
                }, totalSessionDuration);
            }

            function animate(ts){
                const dt=(ts-lastTimestamp);
                lastTimestamp=ts;

                elapsedSessionTime += dt;

                // Log every second for debugging notification timing
                if (Math.floor(elapsedSessionTime / 1000) !== Math.floor((elapsedSessionTime - dt) / 1000)) {
                    console.log(`[Animation Progress] Elapsed: ${(elapsedSessionTime / 1000).toFixed(0)}s / ${(totalSessionDuration / 1000).toFixed(0)}s`);
                }

                // Overall 25-minute session completion check (main timer)
                if(elapsedSessionTime >= totalSessionDuration) {
                    console.log("[Animation Logic] 25-minute total session duration reached in animate loop.");
                    handleSessionCompletion(_sessionTasks);
                    return; 
                }

                let scrollOffset_large = -elapsedSessionTime * scrollSpeed_large;
                let currentY_small = (elapsedSessionTime * speed_small) % (rCH + smallJumperH);
                if (currentY_small < 0) currentY_small += (rCH + smallJumperH);

                smallJumper.style.top=`${currentY_small}px`;
                backgroundScroller.style.transform=`translateY(${scrollOffset_large}px)`;
                
                // --- Individual Task Completion Check Logic (to trigger modal) ---
                if (currentTaskIndex < _sessionTasks.length) {
                    if (elapsedSessionTime >= currentTaskLogicalEndTimeMs) {
                        if (!_sessionTasks[currentTaskIndex].promptedForCompletion) {
                            console.log(`Task end detected for: ${_sessionTasks[currentTaskIndex].name}`);
                            _sessionTasks[currentTaskIndex].promptedForCompletion = true;
                            cancelAnimationFrame(animationFrameId);
                            showTaskCompletionModal(_sessionTasks[currentTaskIndex]);
                            updateSkipButtonState();
                            return; 
                        }
                    }
                } else {
                    console.log("All individual tasks have been processed. Animation continues until 25-minute session ends.");
                    updateSkipButtonState();
                }
                // --- End Individual Task Completion Check Logic ---
                
                animationFrameId=requestAnimationFrame(animate);
            }

            function imageLoadHandler(){
                imagesLoadedCount++;if(imagesLoadedCount===totalImages)initializeAnimation();
            }

            function start(tasksData){
                _sessionTasks = tasksData;
                _sessionTasks.forEach(task => task.promptedForCompletion = false); 

                segments.forEach(seg=>{allColors=allColors.concat(generateGradient(seg.start,seg.end,5))});
                leftColors=allColors;rightColors=allColors;
                
                gradientSection = D.getElementById('gradientSection');
                gradientSection.style.display='flex'; 
                
                smashSound = new Audio('https://raw.githubusercontent.com/boobalootoo/bungeealice/main/smash.wav');
                smashSound.volume = 0.7;

                largeJumper = D.getElementById('largeJumper');
                smallJumper = D.getElementById('smallJumper');

                if (largeJumper) largeJumper.onload=imageLoadHandler;
                if (smallJumper) smallJumper.onload=imageLoadHandler;

                if(largeJumper && largeJumper.complete&&largeJumper.naturalHeight!==0)imageLoadHandler();
                if(smallJumper && smallJumper.complete&&smallJumper.naturalHeight!==0)imageLoadHandler();
            }

            function onResize(){
                if(gradientSection && gradientSection.style.display==='flex'){
                    cancelAnimationFrame(animationFrameId);imagesLoadedCount=0;
                    if(largeJumper.complete&&largeJumper.naturalHeight!==0)imagesLoadedCount++;
                    if(smallJumper.complete&&smallJumper.naturalHeight!==0)imagesLoadedCount++;
                    if(imagesLoadedCount===totalImages)initializeAnimation();else{largeJumper.onload=imageLoadHandler;smallJumper.onload=imageLoadHandler()}
                }
            }
            return {start, onResize, animationFrameId, showSessionReviewModal, hideSessionReviewModal, sessionTimeout};
        })();

        document.addEventListener('DOMContentLoaded',()=>{{
            sessionReviewModalElement = document.getElementById('sessionReviewModal');
            taskCompletionModalElement = document.getElementById('taskCompletionModal');

            taskPlanner.init(gradientAnimation.start);
            window.addEventListener('resize',()=>gradientAnimation.onResize());
        }});
    </script>
</body>
</html>
